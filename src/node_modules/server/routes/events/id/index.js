import React from 'react'
import ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
import { createStore, applyMiddleware } from 'redux'
import reducers from 'app/reducers'
import Html from 'app/helpers/Html'
import EventPage from 'app/components/EventPage'
import { setEvents, setDates, setEvent } from 'app/actions'
import serialize from 'serialize-javascript'
import Sequelize from 'sequelize'
import moment from 'moment'

import Cookies from 'cookies'
import * as storage from 'redux-storage'
import filter from 'redux-storage-decorator-filter'
import createExpressCookieEngine from 'server/custom-redux-storage-engine-express-cookie'

export function get(req, res, next) {
  const db = req.app.get('db')

  createInitialStore(req.cookies, () => {})
  .then(fetchData.bind(null, db, req.params.event))
  .then(dispatchResultsToStore)
  .then(setCookieFromStore.bind(null, res.cookie.bind(res)))
  .then(setServerResponse.bind(null, req.params.event, res.status.bind(res)))
  .then(renderPageFromStore)
  .then(response => res.send(response))
  .catch(next)
}

const sequelizeInstanceToJSON = instance => instance.toJSON()

const sequelizeArrayToJSON = arr => arr.map(sequelizeInstanceToJSON)

const getEvents = (db, filters, dates) => {

  filters = {
    ...filters,
    dates: filters.dates.map(dateId => {
      const date = dates.find(date => date.id === dateId)
      if (date) {
        const base = moment.utc(date.date)
        return { start: base.toDate(), end: base.add(1, 'days').toDate() }
      }
      throw new Error('no matching date')
    })
  }

  const options = {
    include: [
      {
        association: 'venue',
        required: true,
        attributes: [],
        include: [
          {
            association: 'regions',
            attributes: [],
            ...filters.regions && filters.regions.length && {where: {
              id: filters.regions || [],
            }},
          },
        ],
      },
      {
        association: 'disciplines',
        attributes: [],
        ...filters.disciplines && filters.disciplines.length && {where: {
          id: filters.disciplines || [],
        }},
      },
      {
        model: db.models.opening_times,
        // attributes: [],
        where: {
          [Sequelize.Op.or]: [
            ...filters.dates.map(date => {
              return {
                start: {
                  [Sequelize.Op.between]: [ date.start, date.end ]
                },
              }
            }),
          ],
        },
      },
    ],
  }

  return db.models.events.scope('eventlist')
    .findAll(options)
    .then(sequelizeArrayToJSON)
}

const getEvent = (db, eventId) => {
  return eventId ? db.models.events
    .findOne({
      where: { id: eventId }
    })
    .then(sequelizeInstanceToJSON) : null
}

const getDates = (db) => {
  return db.models.dates
    .findAll({ order: [ 'date' ] })
    .then(sequelizeArrayToJSON)
}

const fetchData = (db, event, store) => {
  const { filters = {} } = store.getState()

  return getDates(db)
  .then(dates => {
    return Promise.all([
      store,
      getEvents(db, filters, dates),
      dates,
      getEvent(db, event)
    ])
  })
}

const createInitialStore = (cookies, setCookie) => {
  const rootReducer = storage.reducer(reducers)
  const engine = filter(createExpressCookieEngine('root', cookies, setCookie), [
    'filters'
  ])
  const middleware = storage.createMiddleware(engine)

  const store = createStore(rootReducer, undefined, applyMiddleware(middleware))
  const loader = storage.createLoader(engine)
  return loader(store).then(() => store)
}

const dispatchResultsToStore = ([ store, events, dates, event ]) => {
  store.dispatch(setEvents(events))
  store.dispatch(setDates(dates))
  store.dispatch(setEvent(event))
  return store
}

const setCookieFromStore = (setCookie, store) => {
  setCookie('root', serialize({ filters: store.getState().filters }, { isJSON: true }))
  return store
}

const renderPageFromStore = (store) => {
  return Html(
    ReactDOMServer.renderToString((
      <Provider store={store}>
        <EventPage />
      </Provider>
    )),
    store.getState()
  )
}

const setServerResponse = (eventId, statusCallback, store) => {
  statusCallback(eventId && ! store.getState().event ? 404 : 200)
  return store
}
